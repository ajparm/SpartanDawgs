---
title: "K Means Clustering V3"
author: "Arjun Parmar"
date: "2024-01-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Initialize Session

```{r message=FALSE, warning=FALSE}
library(tidyverse) #Everything 
library(plotly) #3D Graphs
library(kableExtra) # Table Vis
library(mice) #Impution 
library(Boruta) #Logistic Regression
library(e1071) #SVM


set.seed(457023495)

fangraphs_season_level <- read.csv("https://raw.githubusercontent.com/ajparm/SpartanDawgs/main/data/fangraphs_season_level.csv?token=GHSAT0AAAAAACNDELFUTY7XBBSB6MOXI57MZN5BY2Q")

```

# Normalization

Normalizing by innings pitched is problematic lots of Inf and NaN values

The values that we do get however, are not great

```{r}
raw_vars <- c("GS","IP","TBF","W","L","CG","ShO","SV","BS","HLD","SD","MD","Pulls","R","ER","H","HR","SO","BB","IBB","HBP","WP","BK","Events","GB","LD","FB","IFFB","BU","IFH","BUH","Balls","Strikes", "RS", "FRM", "maxEV", "Pitches")

selected_vars <- na.omit(fangraphs_season_level[, raw_vars])
selected_vars <- selected_vars[selected_vars$Pitches != 0, ]
selected_vars <- selected_vars[selected_vars$TBF != 0, ]
selected_vars <- selected_vars[selected_vars$IP != 0, ]

pitch_norm <- (selected_vars / fangraphs_season_level$Pitches)
total_batters_faced_norm <- (selected_vars / fangraphs_season_level$TBF)
innings_pitched_norm <- (selected_vars / fangraphs_season_level$IP)


data_frames <- list(pitch_norm, total_batters_faced_norm, innings_pitched_norm)
norm_list <- c("Pitches", "TBF", "Innings")

num_data_frames <- length(data_frames)
num_columns <- ncol(data_frames[[1]])
cor_matrix <- matrix(NA, nrow = num_columns, ncol = num_data_frames^2,
                     dimnames = list(colnames(data_frames[[1]]), NULL))

# Loop through nomalizations and calculate R2
for (i in 1:num_columns) {
  for (j in 1:num_data_frames) {
    for (k in 1:num_data_frames) {
      cor_value <- cor(data_frames[[j]][, i], data_frames[[k]][, i], use = "pairwise.complete.obs")
      cor_matrix[i, (j - 1) * num_data_frames + k] <- cor_value
      
      # Print correlation with input names
      # cat(sprintf("Correlation between %s and %s for variable %s: %.4f\n",norm_list[j], norm_list[k],colnames(data_frames[[1]])[i], cor_value))
    }
  }
}


# Print the correlation matrix
print(cor_matrix)



```

### Total batters faced vs Pitches thrown

```{r}
raw_vars <- c("GS","IP","TBF","W","L","CG","ShO","SV","BS","HLD","SD","MD","Pulls","R","ER","H","HR","SO","BB","IBB","HBP","WP","BK","Events","GB","LD","FB","IFFB","BU","IFH","BUH","Balls","Strikes", "RS", "FRM", "maxEV", "Pitches")

selected_vars <- na.omit(fangraphs_season_level[, raw_vars])
selected_vars <- selected_vars[selected_vars$Pitches != 0, ]
selected_vars <- selected_vars[selected_vars$TBF != 0, ]

pitch_norm <- (selected_vars / fangraphs_season_level$Pitches)
total_batters_faced_norm <- (selected_vars / fangraphs_season_level$TBF)

data_frames <- list(pitch_norm, total_batters_faced_norm)
norm_list <- c("Pitches", "TBF")

num_data_frames <- length(data_frames)
num_columns <- ncol(data_frames[[1]])
cor_matrix <- matrix(NA, nrow = num_columns, ncol = num_data_frames^2,
                     dimnames = list(colnames(data_frames[[1]]), NULL))

# Loop through nomalizations and calculate R2
for (i in 1:num_columns) {
  for (j in 1:num_data_frames) {
    for (k in 1:num_data_frames) {
      cor_value <- cor(data_frames[[j]][, i], data_frames[[k]][, i], use = "pairwise.complete.obs")
      cor_matrix[i, (j - 1) * num_data_frames + k] <- cor_value
      
      # Print correlation with input names
      #cat(sprintf("Correlation between %s and %s for variable %s: %.4f\n",norm_list[j], norm_list[k],colnames(data_frames[[1]])[i], cor_value))
    }
  }
}


# Print the correlation matrix
cor_matrix[,2]

```

### Absolute Stats --\> Normalized to number of pitches

```{r}
raw_vars <- c("GS","IP","TBF","W","L","CG","ShO","SV","BS","HLD","SD","MD","Pulls","R","ER","H","HR","SO","BB","IBB","HBP","WP","BK","Events","GB","LD","FB","IFFB","BU","IFH","BUH","Balls","Strikes", "RS", "FRM", "maxEV")
              
norm_stats <- (fangraphs_season_level[, names(fangraphs_season_level) %in% raw_vars])/fangraphs_season_level$Pitches
```

### Add the adjusted stats

```{r}
adjusted_vars <- c("ERA", "RS_per_9","K_pct","BB_pct","K_minus_BB_pct","K_per_9","BB_per_9","K_to_BB","H_per_9","HR_per_9","AVG","WHIP","BABIP","LOB_pct","GB_pct","LD_pct","FB_pct","IFFB_pct","GB_to_FB","HR_to_FB","IFH_pct","BUH_pct","FIP","xFIP","SIERA","tERA","kwERA","E_minus_F","RAR","WAR","Dollars","WPA","RE24","REW","pLI","inLI","gmLI","exLI","WPA_to_LI","Clutch","OSwing_pct","ZSwing_pct","Swing_pct","OContact_pct","ZContact_pct","Contact_pct","Zone_pct","FStrike_pct","SwStr_pct","CStr_pct","CSW_pct","ERA_minus","FIP_minus","xFIP_minus","Pace","RA9_WAR","BIP_Wins","LOB_Wins","FDP_Wins","Pull_pct","Cent_pct","Oppo_pct","Soft_pct","Med_pct","Hard_pct","TTO_pct", "K_pct_plus","BB_pct_plus","K_per_9_plus","BB_per_9_plus","K_to_BB_plus","H_per_9_plus","HR_per_9_plus","AVG_plus","WHIP_plus","BABIP_plus","LOB_pct_plus","GB_pct_plus","LD_pct_plus","FB_pct_plus","HR_to_FB_pct_plus","Pull_pct_plus","Cent_pct_plus","Oppo_pct_plus","Med_pct_plus","Hard_pct_plus","EV","LA", "Barrel_pct","HardHit_pct","FA_pct","FAv","SL_pct","SLv","CT_pct","CTv","CB_pct","CBv","CH_pct","CHv","SF_pct","SFv","KN_pct","KNv","XX_pct","PO_pct","wFB_per_c","wSL_per_c","wCT_per_c","wCB_per_c","wCH_per_c","wSF_per_c","wKN_per_c", "FA_pct_sc","FC_pct_sc","FS_pct_sc","FO_pct_sc","SI_pct_sc","SL_pct_sc","CU_pct_sc","KC_pct_sc","EP_pct_sc","CH_pct_sc","SC_pct_sc","KN_pct_sc","UN_pct_sc","vFA_sc","vFC_sc","vFS_sc","vFO_sc","vSI_sc","vSL_sc","vCU_sc","vKC_sc","vEP_sc","vCH_sc","vSC_sc","vKN_sc","FA_X_sc","FC_X_sc","FS_X_sc","FO_X_sc","SI_X_sc","SL_X_sc","CU_X_sc","KC_X_sc","EP_X_sc","CH_X_sc","SC_X_sc","KN_X_sc","FA_Z_sc","FC_Z_sc","FS_Z_sc","FO_Z_sc","SI_Z_sc","SL_Z_sc","CU_Z_sc","KC_Z_sc","EP_Z_sc","CH_Z_sc","SC_Z_sc","KN_Z_sc","wFA_sc","wFC_sc","wFS_sc","wFO_sc","wSI_sc","wSL_sc","wCU_sc","wKC_sc","wEP_sc","wCH_sc","wSC_sc","wKN_sc","wFA_per_c_sc","wFC_per_c_sc","wFS_per_c_sc","wFO_per_c_sc","wSI_per_c_sc","wSL_per_c_sc","wCU_per_c_sc","wKC_per_c_sc","wEP_per_c_sc","wCH_per_c_sc","wSC_per_c_sc","wKN_per_c_sc","OSwing_pct_sc","ZSwing_pct_sc","Swing_pct_sc","OContact_pct_sc","ZContact_pct_sc","Contact_pct_sc","Zone_pct_sc", "botOvr","botStf","botCmd","Stuff_plus","Location_plus","Pitching_plus")
  
norm_stats <- cbind(norm_stats, (fangraphs_season_level[, names(fangraphs_season_level) %in% adjusted_vars]))
```

### Add the pitch arsenal count

```{r}
bot <- (fangraphs_season_level[, names(fangraphs_season_level) %in% c("botOvr_CH","botOvr_CU","botOvr_FA","botOvr_SI","botOvr_SL","botOvr_KC","botOvr_FC","botOvr_FS")])

bot$non_na_count <- rowSums(!is.na(bot))

pitch_plus <- (fangraphs_season_level[, names(fangraphs_season_level) %in% c("Pit_plus_CH","Pit_plus_CU","Pit_plus_FA","Pit_plus_SI","Pit_plus_SL","Pit_plus_KC","Pit_plus_FC","Pit_plus_FS", "Pit_plus_FO")])

pitch_plus$non_na_count <- rowSums(!is.na(bot))

pitch_arsenal <- as.data.frame(cbind(bot$non_na_count,pitch_plus$non_na_count))
colnames(pitch_arsenal) <- c("bot_count", "pitch_plus_count")
  
norm_stats <- cbind(norm_stats,pitch_arsenal)

```

### Normalize to season

normalized stat = actual statÂ  + ((actual stat - min stat) \* (league average stat for that year))

```{r message=FALSE, warning=FALSE}
with_season <- cbind(fangraphs_season_level$Season, norm_stats) 
colnames(with_season) <- c("season",names(with_season)[-1])

twenty_one <- with_season %>% filter(as.character(with_season[,1]) == 2021)
normalized_21 <- data.frame(matrix(nrow = nrow(twenty_one), ncol = ncol(twenty_one)))
colnames(normalized_21) <- colnames(twenty_one)
for (col in names(twenty_one)) {
  column_values <- twenty_one[[col]]
  normalized_values <- column_values + 
                            ((column_values - min(column_values, na.rm = TRUE)) 
                                    * mean(column_values, na.rm = TRUE))
  normalized_21[[col]] <- normalized_values
}

twenty_two <-  with_season %>% filter(as.character(with_season[,1]) == 2022)
normalized_22 <- data.frame(matrix(nrow = nrow(twenty_two), ncol = ncol(twenty_two)))
colnames(normalized_22) <- colnames(twenty_two)
for (col in names(twenty_two)) {
  column_values <- twenty_two[[col]]
  normalized_values <- column_values + 
                            ((column_values - min(column_values, na.rm = TRUE)) 
                                    * mean(column_values, na.rm = TRUE))
  normalized_22[[col]] <- normalized_values
}

twenty_three <-  with_season %>% filter(as.character(with_season[,1]) == 2023)
normalized_23 <- data.frame(matrix(nrow = nrow(twenty_three), ncol = ncol(twenty_three)))
colnames(normalized_23) <- colnames(twenty_three)
for (col in names(twenty_three)) {
  column_values <- twenty_three[[col]]
  normalized_values <- column_values + 
                            ((column_values - min(column_values, na.rm = TRUE)) 
                                    * mean(column_values, na.rm = TRUE))
  normalized_23[[col]] <- normalized_values
}

normalized_dataset <- rbind(normalized_23, normalized_22, normalized_21)[-1]
rm(normalized_23, twenty_one, normalized_22, twenty_two, normalized_21, twenty_three)
```

### Add age

```{r}
normalized_dataset$Age <- fangraphs_season_level$Age
```

# Impute Missing Values

```{r}
missingness_threshold <- .05 * nrow(normalized_dataset) #max number of missing values 


selected_normalized_dataset <- normalized_dataset[names(colSums(is.na(normalized_dataset))[colSums(is.na(normalized_dataset)) < missingness_threshold])]



imputed_rf <- complete(mice(selected_normalized_dataset, method = "rf"))


# Print the missing values 
for (col_name in names(imputed_rf)) {
  na_count <- sum(is.na(imputed_rf[[col_name]]))
  if (na_count != 0) {
    cat(col_name, ":", na_count, "\n")
  }
}



# Remove columns with NAs
imputed_rf <- imputed_rf[, colSums(is.na(imputed_rf)) == 0]



```

##### Kneedle Algorithm

```{r}
kneedle <- function(x, y) {
  n <- length(x)
  s <- numeric(n)
  
  for (i in 3:(n-2)) {
    s[i] <- (y[i+1] - y[i]) / (x[i+1] - x[i]) - (y[i] - y[i-1]) / (x[i] - x[i-1])
  }
  
  knee_index <- which.max(s)
  
  return(list(index = knee_index, x = x[knee_index], y = y[knee_index]))
}

```

# Scale Data

```{r}
imputed_rf_scaled <- scale(imputed_rf)
```

# Variable Selection

```{r}
fangraphs_season_level$Role <- gsub("SP", "1", fangraphs_season_level$Role)
fangraphs_season_level$Role <- gsub("RP", "0", fangraphs_season_level$Role)

var_selection <- as.data.frame(cbind(fangraphs_season_level$Role, imputed_rf_scaled))
var_selection <- apply(var_selection, 2, function(x) as.numeric(as.character(x)))
var_selection <- as.data.frame(var_selection)
```

## Logistic regression

```{r}
logistic_regression <- Boruta(V1 ~ ., data = var_selection, doTrace = 0)
logistic_regression
# Perform a tentative rough fix
rough_fix_mod <- TentativeRoughFix(logistic_regression)
# Get selected attributes
logistic_signif <- getSelectedAttributes(rough_fix_mod)
# Get variable importances
importances <- attStats(rough_fix_mod)
# Filter out rejected variables
selected_importances <- importances[importances$decision != "Rejected", ]
# Order variables by mean importance in descending order
ordered_importances <- selected_importances[order(-selected_importances$meanImp), ]
# Print the ordered list of variable names and their importance
print(ordered_importances[, "meanImp", drop = FALSE])

# Plot feature importance
plot(logistic_regression, ces.axis = 0.7, las = 2, xlab = "", main = "Feature importance")



```

## SVM

```{r}
# Create the SVM model
svm_model <- svm(factor(var_selection$V1) ~ ., data = var_selection)
# Make predictions
predictions <- predict(svm_model, var_selection)
# Create a confusion matrix
confusion_matrix <- table(Actual = var_selection$V1, Predicted = predictions)
# Print the confusion matrix
print(confusion_matrix)
# Calculate weight vectors
w <- t(svm_model$coefs) %*% svm_model$SV
# Calculate the magnitude of the weights
w_magnitude <- apply(w, 2, function(v) sqrt(sum(v^2)))
# Sort the weights in decreasing order
w_sorted <- sort(w_magnitude, decreasing = TRUE)

# Print covariate importance
cat("Covariate Importance:\n")
for (i in seq_along(w_sorted)) {
  cat(sprintf("Feature %d: %.4f\n", i, w_sorted[i]))
}

# Plot covariate importance
plot(w_sorted, main = "Covariate Importance", xlab = "Features", ylab = "Importance")
```

# K Means Clustering

## All Players

##### Max Min function

```{r}
cluster_max_min <- function(cluster){
  max <- t(as.data.frame(apply(cluster[["centers"]], 2, which.max)))
  min <- t(as.data.frame(apply(cluster[["centers"]], 2, which.min)))
  data <- list(
    one_max = colnames(max)[apply(max == 1, 2, any)],
    two_max = colnames(max)[apply(max == 2, 2, any)],
    three_max = colnames(max)[apply(max == 3, 2, any)],
    one_min = colnames(min)[apply(min == 1, 2, any)],
    two_min = colnames(min)[apply(min == 2, 2, any)],
    three_min = colnames(min)[apply(min == 3, 2, any)]
  )
  max_row_length <- max(sapply(data, length))
  padded_data <- lapply(data, function(x) c(x, rep(NA, max_row_length - length(x))))
  df <- data.frame(padded_data)
  print(df)
}
```

##### Optimal Cluster number function

```{r}
opti_cluster <- function(data){
  tot.withinss <- vector(mode="character", length=10)
  for (i in 1:10){
    Cluster <- kmeans(data, center=i, nstart=20, iter.max = 100)
    tot.withinss[i] <- Cluster$tot.withinss
  }
  
  kneedle(1:10,as.numeric(tot.withinss[1:10]))
  
  plot(1:10, tot.withinss[1:10], type="b", pch=19)
  abline(v = as.numeric(kneedle(1:10,as.numeric(tot.withinss[1:10]))[1]), col = "red", lty = 2)
}
```

##### 3D PCA Plot

```{r}
cluster_plot <- function(data,clusters){
  pca_result <- prcomp(data, scale. = TRUE)
  pcs <- pca_result$x[, 1:3]
  plot_3d <- plot_ly(x = pcs[, 1], y = pcs[, 2], z = pcs[, 3], 
                     type = "scatter3d", mode = "markers", 
                     marker = list(color = clusters$cluster))
  clusters_var_name <- deparse(substitute(clusters))
  plot_3d <- plot_3d %>%
    layout(scene = list(
      xaxis = list(title = "PC 1"),
      yaxis = list(title = "PC 2"),
      zaxis = list(title = "PC 3")),
    title = paste0(clusters_var_name,": 3D PCA Cluster Plot"))
  plot_3d
}

```

##### Role Split Plot

```{r}

role_split_plot <- function(data, clusters) {
  # Combine data for plotting
  cluster_data <- cbind(data, as.data.frame(clusters$cluster))
  players_groups <- cbind(clusters$cluster, fangraphs_season_level$Role)
  colnames(players_groups) <- c('group', 'Role')
  rp <- as.data.frame(players_groups) %>% filter(Role == 0) 
  sp <- as.data.frame(players_groups) %>% filter(Role == 1) 
  
  # Get the maximum count across both RP and SP
  max_count <- max(max(table(rp$group)), max(table(sp$group)))
  
  # Plotting RP using ggplot2
  plot_rp <- ggplot(rp, aes(x = as.factor(group))) +
    geom_bar(position = "dodge", stat = "count", fill = "blue", color = "black") +
    labs(title = "RP Distribution by Cluster", x = "Group", y = "Count") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5)) +
    coord_cartesian(ylim = c(0, max_count))

  # Plotting SP using ggplot2
  plot_sp <- ggplot(sp, aes(x = as.factor(group))) +
    geom_bar(position = "dodge", stat = "count", fill = "green", color = "black") +
    labs(title = "SP Distribution by Cluster", x = "Group", y = "Count") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5)) +
    coord_cartesian(ylim = c(0, max_count))
  
  par(mfrow = c(2, 1))
  # Print the two separate graphs
  print(plot_rp)
  print(plot_sp)
}

```

### - Logistic Regression Based

```{r}
# Assuming 'ordered_importances' is the list of important variables
important_vars <- rownames(ordered_importances)

# Filter the 'imputed_rf_scaled' dataframe based on important variables
logistic_filtered_data <- imputed_rf_scaled[, important_vars, drop = FALSE]
```

```{r}
#optimal number of clusters
opti_cluster(logistic_filtered_data)
```

```{r}
# Perform the k-means clustering
log_all_roles_clusters<- kmeans(logistic_filtered_data, 
                                centers = 3, nstart = 20, iter.max = 20)


#Plot Clusters
cluster_plot(logistic_filtered_data,log_all_roles_clusters)

# Retrive Max and Min stats for each group
cluster_max_min(log_all_roles_clusters)


# Pitching role Cluster Group plot
role_split_plot(logistic_filtered_data,log_all_roles_clusters)
```

### - SVM based K means

```{r}
svm_filtered_data <- imputed_rf_scaled[, names(w_sorted)[1:22], drop = FALSE]
```

```{r}
# Optimal cluster number
opti_cluster(svm_filtered_data)
```

```{r}
# Perform the k-means clustering
svm_all_roles_clusters<- kmeans(svm_filtered_data, centers = 3, nstart = 20, iter.max = 20)


#Plot Clusters
cluster_plot(svm_filtered_data,svm_all_roles_clusters)


# Max and Min stats
cluster_max_min(log_all_roles_clusters)



# Pitching role Cluster Group plot
role_split_plot(svm_filtered_data,svm_all_roles_clusters)


```

## Starting Pitchers - SVM

```{r}
# Extract the columns needed for SVM
svm_filtered_data <- imputed_rf_scaled[, names(w_sorted)[1:22], drop = FALSE]
# Combine with the 'Role' column
starting_pitchers <- as.data.frame(cbind(svm_filtered_data, Role = fangraphs_season_level$Role))
# Filter starting pitchers 
starting_pitchers <- starting_pitchers %>% filter(Role == 1)
# Remove the 'Role' column
starting_pitchers <- starting_pitchers[, -which(names(starting_pitchers) == "Role")]
# Convert character columns to numeric
starting_pitchers <- sapply(starting_pitchers, as.numeric)


# Optimal number of clusters
opti_cluster(starting_pitchers)


# Perform the k-means clustering
svm_starting_clusters <- kmeans(starting_pitchers, centers = 3, nstart = 20, iter.max = 20)


#Plot Clusters
cluster_plot(starting_pitchers,svm_starting_clusters)


# Retrive Max and Min stats for each group
cluster_max_min(svm_starting_clusters)
```

## Relief Pitchers

```{r}
# Extract the columns needed for SVM
svm_filtered_data <- imputed_rf_scaled[, names(w_sorted)[1:22], drop = FALSE]
# Combine with the 'Role' column
relief_pitchers <- as.data.frame(cbind(svm_filtered_data, Role = fangraphs_season_level$Role))
# Filter starting pitchers 
relief_pitchers <- relief_pitchers %>% filter(Role == 0)
# Remove the 'Role' column
relief_pitchers <- relief_pitchers[, -which(names(relief_pitchers) == "Role")]
# Convert character columns to numeric
relief_pitchers <- sapply(relief_pitchers, as.numeric)


# Optimal number of clusters
opti_cluster(relief_pitchers)


# Perform the k-means clustering
svm_relief_clusters <- kmeans(relief_pitchers, centers = 3, nstart = 20, iter.max = 20)


#Plot Clusters
cluster_plot(relief_pitchers,svm_relief_clusters)


# Retrive Max and Min stats for each group
cluster_max_min(svm_relief_clusters)
```

# Export Pitchers

```{r}
starters <- fangraphs_season_level %>% 
  filter(Role == 1) %>%
  mutate(Group = svm_starting_clusters$cluster) %>%
  select(Group, everything())
#write.csv(starters,"file_path/starters.csv")

relief <- fangraphs_season_level %>% 
  filter(Role == 0) %>%
  mutate(Group = svm_relief_clusters$cluster) %>%
  select(Group, everything())
#write.csv(relief,"file_path/relivers.csv")


```

# Starter analysis

```{r}
# Starting pitchers 
# Extract the columns needed for SVM
svm_filtered_data <- imputed_rf[, names(w_sorted)[1:22], drop = FALSE]
# Combine with the 'Role' column
starting_pitchers <- as.data.frame(cbind(svm_filtered_data, Role = fangraphs_season_level$Role))
# Filter starting pitchers 
starting_pitchers <- starting_pitchers %>% filter(Role == 1)
# Remove the 'Role' column
starting_pitchers <- starting_pitchers[, -which(names(starting_pitchers) == "Role")]
# Convert character columns to numeric
starting_pitchers <- sapply(starting_pitchers, as.numeric)
# Label starter groups 
starting_pitchers <- as.data.frame(cbind(starting_pitchers, group = svm_starting_clusters$cluster))


# Relief pitchers 
# Extract the columns needed for SVM
svm_filtered_data <- imputed_rf[, names(w_sorted)[1:22], drop = FALSE]
# Combine with the 'Role' column
relief_pitchers <- as.data.frame(cbind(svm_filtered_data, Role = fangraphs_season_level$Role))
# Filter starting pitchers 
relief_pitchers <- relief_pitchers %>% filter(Role == 0)
# Remove the 'Role' column
relief_pitchers <- relief_pitchers[, -which(names(relief_pitchers) == "Role")]
# Convert character columns to numeric
relief_pitchers <- as.data.frame(sapply(relief_pitchers, as.numeric))


# t tests
starting_group_comparison <- matrix(NA, nrow = 22, ncol = 3)
for (g in 1:3) {
  for (stat in 1:22) {
    a <- starting_pitchers %>% filter(group == g)
    result <- t.test(a[, stat], relief_pitchers[, names(relief_pitchers) == names(a)[stat]])
    starting_group_comparison[stat, g] <- result$p.value  # Store p-values in the matrix
  }
}
print(starting_group_comparison)




# Average minimum distance
starting_group_distance <- matrix(NA, nrow = 22, ncol = 3)
for (g in 1:3) {
  for (stat in 1:22) {
    a <- starting_pitchers %>% filter(group == g)
    distance <- (1/nrow(a)) * sum(sapply(1:nrow(a), function(i) min(abs(a[i, stat] - relief_pitchers[, names(relief_pitchers) == names(a)[stat]])))) +
                (1/nrow(relief_pitchers)) * sum(sapply(1:nrow(relief_pitchers), function(j) min(abs(a[, stat] - relief_pitchers[j, names(relief_pitchers) == names(a)[stat]]))))
    
    starting_group_distance[stat, g] <- distance
  }
}
print(starting_group_distance)
colSums(starting_group_distance)
cat("Starting group", which.min(colSums(starting_group_distance)), "is the most similar to relief pitchers.\n")





# Boxplots
boxplot_list <- list()
for (stat_col_name in names(starting_pitchers)[1:22]) {
  
  relief_data <- relief_pitchers[, stat_col_name]
  starting_group_data <- lapply(1:3, function(g) starting_pitchers[starting_pitchers$group == g, stat_col_name])
  
  all_data <- c(list(Relief = relief_data), setNames(starting_group_data, paste0("Starting Group", 1:3)))
  
  boxplot(all_data, 
          main = paste("Boxplot for Variable:", stat_col_name),
          ylab = paste("Value of", stat_col_name),
          col = c("blue", "red", "green", "purple"))
  
  boxplot_list[[stat_col_name]] <- all_data
}
```

# Relief Pitchers

```{r}
# Extract the columns needed for SVM
svm_filtered_data <- imputed_rf[, names(w_sorted)[1:22], drop = FALSE]
# Combine with the 'Role' column
relief_pitchers <- as.data.frame(cbind(svm_filtered_data, Role = fangraphs_season_level$Role))
# Filter starting pitchers 
relief_pitchers <- relief_pitchers %>% filter(Role == 0)
# Remove the 'Role' column
relief_pitchers <- relief_pitchers[, -which(names(relief_pitchers) == "Role")]
# Convert character columns to numeric
relief_pitchers <- sapply(relief_pitchers, as.numeric)
# Label starter groups 
relief_pitchers <- as.data.frame(cbind(relief_pitchers, group = svm_relief_clusters$cluster))


# Extract the columns needed for SVM
svm_filtered_data <- imputed_rf[, names(w_sorted)[1:22], drop = FALSE]
# Combine with the 'Role' column
starting_pitchers <- as.data.frame(cbind(svm_filtered_data, Role = fangraphs_season_level$Role))
# Filter starting pitchers 
starting_pitchers <- starting_pitchers %>% filter(Role == 1)
# Remove the 'Role' column
starting_pitchers <- starting_pitchers[, -which(names(starting_pitchers) == "Role")]
# Convert character columns to numeric
starting_pitchers <- as.data.frame(sapply(starting_pitchers, as.numeric))



# t test
relief_group_comparison <- matrix(NA, nrow = 22, ncol = 3)
for (g in 1:3) {
  for (stat in 1:22) {
    a <- relief_pitchers %>% filter(group == g)
    result <- t.test(a[, stat], starting_pitchers[, names(starting_pitchers) == names(a)[stat]])
    relief_group_comparison[stat, g] <- result$p.value  # Store p-values in the matrix
  }
}
print(relief_group_comparison)




# Average minimum disatnce 
relief_group_distance <- matrix(NA, nrow = 22, ncol = 3)
for (g in 1:3) {
  for (stat in 1:22) {
    a <- relief_pitchers %>% filter(group == g)
    distance <- (1/nrow(a)) * sum(sapply(1:nrow(a), function(i) min(abs(a[i, stat] - starting_pitchers[, names(starting_pitchers) == names(a)[stat]])))) +
                (1/nrow(starting_pitchers)) * sum(sapply(1:nrow(starting_pitchers), function(j) min(abs(a[, stat] - starting_pitchers[j, names(starting_pitchers) == names(a)[stat]]))))
    
    relief_group_distance[stat, g] <- distance
  }
}
print(relief_group_distance)
colSums(relief_group_distance)
cat("Relief group", which.min(colSums(relief_group_distance)), "is the most similar to starting pitchers.\n")


# Box plots
boxplot_list <- list()
for (stat_col_name in names(relief_pitchers)[1:22]) {
  
  starting_data <- starting_pitchers[, stat_col_name]
  
  relief_group_data <- lapply(1:3, function(g) relief_pitchers[relief_pitchers$group == g, stat_col_name])
  

  all_data <- c(list(Starting = starting_data), setNames(relief_group_data, paste0("Relief Group", 1:3)))
  
  boxplot(all_data, 
          main = paste("Boxplot for Variable:", stat_col_name),
          ylab = paste("Value of", stat_col_name),
          col = c("blue", "red", "green", "purple"))
  
  boxplot_list[[stat_col_name]] <- all_data
}
```

# Relief to Starting Pitcher Identification

```{r}
start <- imputed_rf[fangraphs_season_level$Role==1,]

# Fit model
starting_fip_model <- lm(FIP ~ ., data = start, singular.ok = T)

# Extract significant variables 
start_summary_model <- summary(starting_fip_model)
significant_variables <- start_summary_model$coefficients[start_summary_model$coefficients[, "Pr(>|t|)"] < 0.05, ]


# Fit the new linear regression model with only significant variables
significant_starting_fip_model <- lm(FIP ~ ., data = start[, c("FIP", (rownames(significant_variables)[-1]))])



# ID relief pitchers with potential
relief_g3 <- cbind(imputed_rf, fangraphs_season_level$PlayerId, fangraphs_season_level$Season, fangraphs_season_level$NameASCII, fangraphs_season_level$IP)
colnames(relief_g3)[(ncol(relief_g3)-3):ncol(relief_g3)] <- c("PlayerId", "Season", "NameASCII","ip_raw")
relief_g3 <- merge(relief_g3, relief[, c("PlayerId", "Season", "Group")], by.x = c("PlayerId", "Season"), by.y = c("PlayerId", "Season"))
relief_g3 <- relief_g3[relief_g3$Group == which.min(colSums(relief_group_distance)), ]

# Predict using the starting pitcher FIP model
predicted_values <- predict(significant_starting_fip_model, newdata = relief_g3)

# Rank 'em 
reli_to_start_fip_proj <- as.data.frame(cbind(relief_g3[, c("NameASCII", "PlayerId", "Season", "ip_raw")], predicted_values))

reli_to_start_fip_proj <-reli_to_start_fip_proj %>% filter(reli_to_start_fip_proj$ip_raw > 27)

starting_top_prospects <- reli_to_start_fip_proj[order(-reli_to_start_fip_proj$predicted_values), ]
starting_top_prospects <- head(starting_top_prospects, 10)
print(starting_top_prospects)

```

# Starting to Relief Pitcher Identification

```{r}
reli <- imputed_rf[fangraphs_season_level$Role==0,]

# Fit model
relief_fip_model <- lm(FIP ~ ., data = reli)

# Extract significant variables 
reli_summary_model <- summary(relief_fip_model)
reli_significant_variables <- reli_summary_model$coefficients[reli_summary_model$coefficients[, "Pr(>|t|)"] < 0.05, ]


# Fit the new linear regression model with only significant variables
significant_relief_fip_model <- lm(FIP ~ ., data = reli[, c("FIP", (rownames(reli_significant_variables)[-1]))])



# ID Starting pitchers with potential
starting_g3 <- cbind(imputed_rf, fangraphs_season_level$PlayerId, fangraphs_season_level$Season, fangraphs_season_level$NameASCII, fangraphs_season_level$IP)
colnames(starting_g3)[(ncol(starting_g3)-3):ncol(starting_g3)] <- c("PlayerId", "Season", "NameASCII","ip_raw")
starting_g3 <- merge(starting_g3, relief[, c("PlayerId", "Season", "Group")], by.x = c("PlayerId", "Season"), by.y = c("PlayerId", "Season"))
starting_g3 <- starting_g3[starting_g3$Group == which.min(colSums(starting_group_distance)), ]

# Predict using the relief pitcher FIP model
reli_predicted_values <- predict(significant_relief_fip_model, newdata = starting_g3)

# Rank 'em 
start_to_reli_fip_proj <- as.data.frame(cbind(starting_g3[, c("NameASCII", "PlayerId", "Season", "ip_raw")], reli_predicted_values))

start_to_reli_fip_proj <-start_to_reli_fip_proj %>% filter(start_to_reli_fip_proj$ip_raw > 27)

relief_top_prospects <- start_to_reli_fip_proj[order(-start_to_reli_fip_proj$reli_predicted_values), ]
relief_top_prospects <- head(relief_top_prospects, 10)
print(relief_top_prospects)

```

# Seasonal changes

## All players

vertical lines show in season role changes

```{r}
fangraphs_season_level$PlayerId
fangraphs_season_level$Role
fangraphs_season_level$Season


ggplot(fangraphs_season_level, aes(x = Season, y = Role, group = PlayerId, color = as.factor(PlayerId))) +
  geom_line() +
  geom_point() +
  labs(title = "Player Roles Across Seasons",
       x = "Season",
       y = "Role") +
  theme_minimal() +
  theme(legend.position = "none") 



```
